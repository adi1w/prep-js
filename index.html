<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>interview js</title>
  <link rel="stylesheet" href="./index.css">
</head>

<body>

  <h2 class="heading">INTERVIEW PREP QUESTION OF JS </h2>

  <h1 class="top">DAY1
    <h2 class="question1">
      QUES1. Difference between “ == “ and “ === “ operators.

    </h2>

    <div class="answer1"> Ans1. <br>In JavaScript, the "==" and "===" operators are used for comparison, but they behave
      differently.
      <br>

      The "==" (double equals) operator checks for equality between two values after performing type coercion if
      necessary. Type coercion means that JavaScript tries to convert the operands to a common type before making the
      comparison.<br>
      <br>
    <div class="out"> example-1
      let a = 5;
      let b = "5"; <br>
      console.log(a == b); // true <br>
      console.log(a === b); // false <br>

      <br>
      example-2
      console.log(1 == '1'); <br>
      console.log(true == 1); <br>
      console.log(null == undefined); <br>
      </p>
    </div>
    </div>
    <br>
    <hr>

    <h2 class="question2">
      QUES2. What are the differences between var, let and const?
    </h2>

    <div class="answer2">
      Ans2. <br>var: Variables declared with var are function-scoped. This means that a variable declared with var is
      accessible within the entire function in which it is declared, regardless of block scope. If a variable is
      declared with var outside of any function, it becomes globally scoped.<br>
      <br>
      let is block-scoped. It allows you to declare variables that are limited in scope to the block, statement, or
      expression in which they are declared. Variables declared with let are not hoisted to the top of their scope, so
      they must be declared before they are used.<br><br>
      Variables declared with const are constant and cannot be reassigned after they are initialized. They are
      commonly used to declare constants or immutable values.<br><br>



      <br>
    <div class="out"> Example:-
      // var example
      var x = 10; <br>
      <br> if (true) { <br>
      <br> var x = 20; <br>
      }
      <br> console.log(x); // outputs 20

      // let example
      let y = 10; <br>
      <br> if (true) { <br>
      <br> let y = 20; <br>
      }
      <br> console.log(y); // outputs 10

      // const example
      <br> const z = 10; <br>
      <br> // z = 20; // throws an error <br>
      <br> console.log(z); // outputs 10 <br>
      
    </div>
    </div>
    <br>
    <hr>

    <h2 class="question3">
      Ques3. What is hoisting?
    </h2>

    <div class="answer3">
    Ans3.  Hoisting is a behavior in JavaScript where variable and function declarations are moved to the top of their
      respective scopes during the compilation phase, before the code is actually executed. This means that even if a
      variable or function is declared after it is used, it can still be accessed.
      <br>
      <br>
      <div class="out" exapmle:- <br>
        <br> x = 5;
        <br> console.log(x); <br>
        <br> var x; <br>


        'In this code, x is assigned the value of 5 before it is declared. However, because of hoisting, the variable
        declaration is moved to the top of the scope, so the code is interpreted as:''
        <br>
        var x; <br>
        <br> x = 5;

        <br> console.log(x);
      </div>
    </div>

    <br>
    <hr>
    <h2 class="question4">
      Ques4. What is a Temporal Dead Zone?
    </h2>


    <div class="answer4">
   Ans4.   A Temporal Dead Zone (TDZ) is a period of time during the code execution where a variable exists in the scope but
      cannot be accessed due to a restriction known as "temporal dead zone". <br>
      The TDZ occurs for let and const variables, which are block-scoped variables that cannot be accessed before they
      are declared.<br>
      <br>

      <div class="out">OUTPUT:-
        <br><br>
        let x; <br>
        console.log(x); // undefined <br>
        x = 10; <br>
        console.log(x); // 10 <br>
      </div>

    </div>

    <br>
    <hr>


    <h2 class="question5">
      Ques5. What is execution context?
    </h2>

    <div class="answer5">
   Ans5.   In JavaScript, an execution context can be defined as the environment in which a piece of code is executed. It
      contains information about the currently executing code, such as variable values, function calls, and the scope
      chain.<br>
      <br>

      <br> When JavaScript code is executed, a new execution context is created. This context is responsible for
      managing the execution of the code within its scope, and it is destroyed once the code execution is completed.

      <div class="out">OUTPUT:-
        <br>
        <br>
        function myFunction() { <br>
        var a = 10; <br>
        console.log(a); <br>
        }

        myFunction(); <br>

      </div>
    </div>

    <br>
    <hr>

    <h2 class="question6">
      Ques6. What is an event loop and call stack?
    </h2>

    <div class="answer6">
   Ans6.   The call stack is a data structure that keeps track of the function calls in a program.<br>
      <br> Whenever a function is called, it is added to the top of the call stack, and when the function completes, it
      is removed from the top of the stack.
      <br>This allows JavaScript to keep track of where it is in a program's execution and which function to return to
      after the current one finishes.

      <div class="out">EXAMPLE OF EVENT loop
        function greet(name) { <br>
        console.log("Hello, " + name + "!"); <br>
        }

        function sayHello() { <br>
        const name = "Aditi"; <br>
        greet(name); <br>
        }

        sayHello(); // "Hello, Aditi!" <br>
      </div>


      <br> The event loop is a mechanism that allows JavaScript to handle asynchronous code, such as waiting for user
      input or network requests. The event loop constantly checks for any events that need to be processed, and when it
      finds one, it adds it to a queue.
      <div class="out">EXAMPLE OF CALL STACK
        console.log("Start"); <br>

        <br> setTimeout(function() { <br>
        <br> console.log("First timeout"); <br>
        }, 1000); <br>

        <br> setTimeout(function() { <br>
        <br> console.log("Second timeout"); <br>
        <br> }, 500); <br>

        console.log("End"); <br>

      </div>
    </div>
<br>
<hr>
    <h2 class="question7">
      Ques7. What is creation phase and execution phase?
    </h2>

    <div class="answer7">
   Ans7.   1. Creation Phase: <br>
      The creation phase involves the creation of the variable and function declarations, which are then stored in
      memory. During this phase, JavaScript also sets up the scope chain and the "this" keyword. <br><br>
      2. Execution Phase:
      The execution phase refers to the moment when the code is actually executed, line by line. During this phase,
      JavaScript reads and executes each line of code in sequence, using the information stored in memory during the
      creation phase.



      <div class="out">CREATION PHASE <br>
        function myFunction() { <br>
        var myVariable = 1; <br>
        console.log(myVariable); <br>
        }
        <br>

      </div>

      <div class="out">EXECUTION PHASE <br>
        myFunction(); <br>

        function myFunction() { <br>
        var myVariable = 1; <br>
        console.log(myVariable); <br>
        }

      </div>
    </div>
  </h1>
<br>
<hr>

  <h1 class="top2">Day2
    <h2 class="question8">
      Ques8. What are callbacks?
    </h2>

    <div class="answer8">
   Ans8.   A callback is a function that is passed as an argument to another function and is executed after some event or
      task
      is completed.<br>
      <br> callback is a function which is to be executed after another function has finished execution. <br>
      <br> Any function that is passed as an argument to another function so that it can be executed in that other
      function is called as a callback function.<br>

      <br>

      <div class="out">OUTPUT:- <br>
        <br> function getUserData(userId, callback) { <br>
        // Make a request to get user data <br>
        // Once the data is received, call the callback function with the data <br>
        const userData = { name: "Aditi", age: 25, email: "aditi12@gmail.com" }; <br>
        callback(userData); <br>
        }
        <br>
        // Define a callback function to process the user data <br>
        function processUserData(userData) { <br>
        console.log("Name:", userData.name); <br>
        console.log("Age:", userData.age); <br>
        console.log("Email:", userData.email); <br>
        }
        <br>
        // Call the getUserData function with the user ID and the callback function <br>
        getUserData(123, processUserData); <br>
      </div>
    </div>
    <br>
    <hr>

    <h2 class="question9">
      Ques9. What is meant by first class functions?
    </h2>


    <div class="answer9">
  Ans9.    first class function means that functions can be assigned to variables, passed as arguments to other functions,
      and
      returned from functions like any other data type.
      <br>
    </div>


    <div class="out">EXAMPLE: -
      <br>
      <br>
      // defining a function as a variable <br>
      const add = function(x, y) { <br>
      return x + y;
      } <br>

      / / passing a function as an argument to another function <br>
      function calculate(operation, x, y) { <br>
      return operation(x, y); <br>
      }

      const result = calculate(add, 2, 3); <br>

      console.log(result); // result will be 5 <br>
    </div>
<br>
<hr>


    <h2 class="question10">
 Ques10.     What is the spread operator?
    </h2>

    <div class="answer10">
 Ans10.     The spread operator is a feature in JavaScript that allows an iterable (such as an array or a string) to be
      expanded
      into individual elements. <br>
      The spread operator is denoted by three dots (...) and can be used in several ways in JavaScript.<br>

    </div>


    <div class="out">EXAMPLE:
      <br>
      <br>
      const array1 = [1, 2, 3]; <br>
      const array2 = [4, 5, 6]; <br>
      const combinedArray = [...array1, ...array2]; <br>
      console.log(combinedArray); <br>

    </div>
<br>
<hr>

    <h2 class="question11">
  Ques11.    What are pure functions?
    </h2>

    <div class="answer11">
   Ans11.   Pure functions are functions that always return the same output for a given input and do not have any side
      effects,
      meaning they do not modify any variables or states outside of the function.

    </div>


    <div class="out">EXAMPLE
      function add(a, b) { <br>
      return a + b; <br>
      }

    </div>
    <br>
    <hr>


    <h2 class="question12">
      Ques12. what are arrow functions?
    </h2>

    <div class="answer12">
   Ans12.   Arrow functions are a shorthand way of writing JavaScript functions.
      <br> They were introduced in ES6 and provide a more concise syntax for writing functions.

    </div>
    <br>
    <hr>

    <h2 class="question13">
   Ques13.   What is the for-in loop in JavaScript? Give its syntax.
    </h2>


    <div class="answer13">
   Ans13.   The for-in loop in JavaScript is used to loop over the properties of an object.
      <br>
      It is often used when you don't know the exact number of properties in an object, or when you want to perform a
      certain operation on all the properties of an object.

    </div>

    <div class="out">SYNTAX <br>
      <br> for (variable in object) { <br>
      // code to be executed <br>
      }

    </div>

    <br>
    <br>

    <div class="out"> Example
      const person = { <br>
      name: 'John', <br>
      age: 30, <br>
      gender: 'male' <br>
      };

      for (let property in person) { <br>
      console.log(' ${property}: ${person[property]}'); <br>
      }
    </div>
    <br>
    <hr>

    <h2 class="question14">
      Ques14. Explain Local Scope, Block Scope, Functional Scope and Scope Chain in javascript
    </h2>


    <div class="answer14">
      Ans14. Scope refers to the set of variables, functions, and objects that are accessible in a particular part of
      your
      code.
      <br> There are different types of scope in JavaScript: <br>
      <br>

      1. Local Scope:
      A variable declared within a function has local scope. It can only be accessed within the function in which it is
      declared.<br><br>

      <div class="out"> EXAMPLE OF LOCAL SCOPE
        <br><br>
        function myFunction() { <br>
        var x = 10; // local variable <br>
        console.log(x); // Output: 10<br>
        }
        myFunction(); <br>
        console.log(x); <br>
      </div>


      2. Block Scope:
      Variables declared with the let or const keywords inside a block ({}) have block scope. <br>
      A block is any code surrounded by curly braces, such as an if statement or a for loop. <br>
      Block scope variables can only be accessed within the block in which they are declared. <br><br>

      <div class="out">EXAMPLE OF BLOCK SCOPE
        <br>
        <br>
        if (true) { <br>
        let x = 10; // block scope variable <br>
        console.log(x); // Output: 10 <br>
        }
        console.log(x); // Output: Uncaught ReferenceError: x is not defined <br>

      </div>

      3. Functional Scope:
      A variable declared outside of a function has global scope, and can be accessed from any part of your code. <br>
      However, this can lead to naming conflicts and other issues. One way to avoid this is by using functional scope.
      <br>
      In this approach, you wrap your code in an anonymous function that is immediately invoked. Variables declared
      inside
      the function have local scope, and cannot be accessed outside of it. <br>
      <br>
      <br>
      <div class="out">EXAMPLE OF FUNCTIONAL SCOPE <br>
        <br>
        (function() { <br>
        var x = 10; // functional scope variable <br>
        console.log(x); // Output: 10 <br>
        })();
        console.log(x); // Output: Uncaught ReferenceError: x is not defined <br>

      </div>

      4. Scope Chain: The scope chain is the hierarchy of scopes in your code. <br>
      When you reference a variable, JavaScript looks for it in the current scope, and if it's not found, <br>
      it looks in the outer scope, and so on until it reaches the global scope. This is called the scope chain. <br>
      <br>

      <div class="out">EXAMPLE OF SCOPE CHAIN <br>
        <br>
        var x = 10; // global variable <br>

        function outerFunction() { <br>
        var y = 20; // outerFunction scope variable <br>

        function innerFunction() { <br>
        var z = 30; // innerFunction scope variable <br>
        console.log(x + y + z); // Output: 60 <br>
        }

        innerFunction(); <br>
        }

        outerFunction(); <br>
        console.log(x + y + z); // Output: Uncaught ReferenceError: y is not defined <br>

      </div>
    </div>

    <br>
    <hr>

    <h2 class="question15">
      Ques15. What is difference between null and undefined and where to use what? <br>

    </h2>
    <br>

    <div class="answer15">
      Ans15. Null means that a variable has been declared but has been assigned a null value.
      <br>
      undefined means that a variable has been declared but has not been assigned a value.
    </div>

    <br>

    <div class="out">EXAMPLE
      let myValue = null; <br>
      let myOtherValue; <br>

      console.log(myValue); // logs null <br>
      console.log(myOtherValue); // logs undefined <br>

      if (myValue === null) { <br>
      console.log("myValue is null"); <br>
      }

      if (myOtherValue === undefined) { <br>
      console.log("myOtherValue is undefined"); <br>
      } <br>

    </div>

    <br>
    <hr>

    <h2 class="question16">
      Ques16. What are closures? Give an example of closure.
    </h2>

    <div class="answer16">
      Ans16. Closures are used in JavaScript to create private variables and methods, which are not accessible from
      outside the closure.
      <br>
      In simpler terms, when a function uses variables from outside of its own scope, those variables are "closed over"
      by
      the function and can still be accessed even after the function has finished executing.<br>
    </div>

    <div class="out">EXAMPLE
      function outerFunction() { <br>
      const outerVariable = "Hello"; <br>

      function innerFunction() { <br>
      const innerVariable = "World"; <br>
      console.log(outerVariable + " " + innerVariable); <br>
      }

      return innerFunction; <br>
      }

      const myFunction = outerFunction(); <br>
      myFunction(); // Output: "Hello World" <br>
    </div>
  </h1>
<br>
<hr>


  <h1 class="top3">Day3
    <h2 class="question17">
      Ques17. Explain call(), apply() and, bind() methods. Give an example of call(), apply(), bind()
    </h2>

    <br>

    <div class="answer17">
      Ans17.
      call(), apply(), and bind() are all methods available in JavaScript that allow you to call a function with a
      specific this context and arguments.<br>
      1. call():is a function that helps you change the context of the invoking function.<br>

      In layperson's terms, it helps you replace the value of this inside a function with whatever value you want.<br>

      <div class="out">EXAMPLE OF CALL()
        <br> const person = { <br>
        firstName: "John", <br>

        lastName: "Doe", <br>
        fullName: function() { <br>
        console.log(this.firstName + " " + this.lastName); <br>
        }
        }; <br>

        const person2 = {
        firstName: "aditi", <br>
        lastName: "singh" <br>
        };


        person.fullName.call(person2); // Output: Jane Doe <br>
      </div>


      2. apply(): is very similar to the call function. The only difference is that in apply you can pass an array as an
      argument list.<br>
      <div class="out">EXAMPLE OF APPLY()
        const numbers = [5, 10, 15, 20]; <br>

        const sum = Array.prototype.reduce.apply(numbers, [(a, b) => a + b]); <br>
        console.log(sum); // 50 <br>
      </div>

      3. bind(): is a function that helps you create another function that you can execute later with the new context of
      this that is provided.<br>
      <div class="out">EXAMPLE OF BIND()
        const person = { <br>
        firstName: 'Aditi', <br>
        lastName: 'Doe', <br>
        fullName: function() { <br>
        return this.firstName + ' ' + this.lastName; <br>
        }
        };

        const getFullName = person.fullName.bind({firstName: 'Jane', lastName: 'Doe'}); <br>
        console.log(getFullName()); // Jane Doe <br>

      </div>


      call() and apply() are similar in that they allow you to set the this context for a function, but they differ in
      how
      they handle arguments.
      <br> call() takes an argument list, while apply() takes an array of arguments.<br>

      Bind() is used to create a new function with a specific this context and pre-set arguments. It does not call the
      function immediately but instead returns a new function that can be called later.<br>
    </div>


    <br>
    <hr>


    <h2 class="question18">
      Ques18. What are function constructors?
    </h2>

    <div class="answer18">
      Ans18. Function constructors in JavaScript are a way of creating objects using a constructor function. <br>
      <br>This allows you to create multiple instances of an object with similar properties and methods.
    </div>

    <div class="out">EXAMPLE
      <br>

      // Define the constructor function
      function Person(name, age) { <br>
      this.name = name; <br>
      this.age = age; <br>
      this.greet = function() { <br>
      console.log("Hello, my name is " + this.name + " and I am " + this.age + " years old."); <br>
      } <br>
      } <br>

      <br>
      // Create new instances of the object using the constructor function
      var person1 = new Person("Alice", 25); <br>
      var person2 = new Person("Bob", 30); <br>

      <br>
      // Call the greet method on each object
      person1.greet(); // Output: "Hello, my name is Alice and I am 25 years old." <br>
      person2.greet(); // Output: "Hello, my name is Bob and I am 30 years old." <br>

    </div>
<br>
<hr>

    <h2 class="question19">
      Ques19. Explain prototypes?
    </h2>


    <div class="answer19">
      Ans19. Prototypes in JavaScript are a mechanism for object-oriented programming that allows objects to inherit
      properties and methods from other objects.
      <br> Every object in JavaScript has a prototype, which is an object that acts as a template for the new objects
      created from it.

    </div>


    <div class="out">EXAMPLE
      function Person(name, age) { <br>
      this.name = name; <br>
      this.age = age; <br>
      }

      Person.prototype.greet = function() { <br>
      console.log("Hello, my name is " + this.name + " and I'm " + this.age + " years old."); <br>
      }

      var person1 = new Person("Aditi", 25); <br>
      person1.greet(); // Output: Hello, my name is Aditi and I'm 25 years old. <br>
    </div>

<br>
<hr>


    <h2 class="question20">
      Ques20. What is prototype chain?
    </h2>

    <div class="answer20">
      Ans20. Every object has a property called prototype which refers to another object. This creates a chain of
      objects,
      where each object's prototype is another object. This is called the prototype chain. <br>
      <br>

      When you access a property of an object, JavaScript looks for the property in the object itself.
      <br> If the property is not found, it looks in the object's prototype, then in the prototype's prototype, and so
      on
      until it either finds the property or reaches the end of the prototype chain.<br>
    </div>

    <div class="out">
      <br>
      <br> // Define a constructor function <br>
      function Animal(name) { <br>
      this.name = name; <br>
      }

      <br> // Add a method to the Animal prototype <br>
      Animal.prototype.walk = function() { <br>
      console.log(this.name + ' is walking.'); <br>
      };

      <br>// Create a new instance of Animal <br>
      var cat = new Animal('Whiskers'); <br>

      <br>// Call the walk method on the cat instance <br>
      cat.walk(); // Output: Whiskers is walking. <br>

      <br>// The walk method is not defined on the cat instance itself, <br>
      <br>// but it is found in the Animal prototype via the prototype chain. <br>

    </div>
<br>
<hr>



    <h2 class="question21">
      Ques21. What are objects in javascript?
    </h2>

    <div class="answer21">
      Ans21. In JavaScript, objects are data structures that allow you to store and organize related data and
      functionality. <br>
      <br> They are created using the object literal notation or the Object constructor function.
    </div>


    <div class="out"> EXAMPLE

      const person = { <br>
      name: 'Aditi', <br>
      age: 25, <br>
      address: {
      street: 'SOMDUT',
      city: 'Meerut', <br>
      state: 'UP',
      zip: '25004' <br>
      },
      sayHello: function() { <br>
      console.log('Hello, my name is ${this.name}'); <br>
      }
      };

    </div>
<br>
<hr>

    <h2 class="question22">
      Ques22. What is the use of setTimeout?
    </h2>

    <div class="answer22">
      Ans22. SetTimeout() is a JavaScript function that allows you to schedule a function to be executed after a certain
      amount of time has passed.
      The function takes two parameters: the first is the function you want to execute, and the second is the time delay
      in milliseconds.
    </div>

    <div class="out">EXAMPLE
      function greeting() { <br>
      console.log("Hello, world!"); <br>
      }

      setTimeout(greeting, 2000); <br>
      greeting() <br>
    </div>
    <br>
    <hr>

    <h2 class="question23">
      Ques23. What is the purpose of async/await keywords?
    </h2>

    <div class="answer23">
      Ans23. Async/await is a feature in JavaScript that allows asynchronous code to be written in a synchronous style.
      <br> This makes it easier to write and read code that deals with promises, which are a way to handle asynchronous
      operations in JavaScript.

      <br> The async keyword is used to define a function that returns a promise, while the await keyword is used to
      wait
      for a promise to resolve.
    </div>


    <div class="out">EXAMPLE
      async function getData() { <br>
      const response = await fetch('https://api.example.com/data'); <br>
      const data = await response.json(); <br>
      return data; <br>
      }

      console.log(getData()); <br>

    </div>

    <br>
    <hr>

    <h2 class="question24">
      Ques24. What is the DOM?
    </h2>

    <div class="answer24">
   Ans24.   The DOM stands for Document Object Model, and it's a way for web developers to interact with and manipulate HTML
      and
      XML documents using JavaScript
    </div>


    <div class="out">EXAMPLE
      <!DOCTYPE html>
      <html>

      <head>
        <title>My Webpage</title>
      </head>

      <body>
        <h1>Welcome to my webpage!</h1> <br>
        <p>Here's some text for you to read.</p> <br>

        <script>
          // Select the first <p> element on the page
          var pElement = document.querySelector('p'); <br>

		// Change the text inside the <p> element
              pElement.textContent = 'This is new text!'; <br>

		// Create a new <button> element
                  var buttonElement = document.createElement('button'); <br>

		// Add some text to the button
                    buttonElement.textContent = 'Click me!';    <br>

		// Append the button to the end of the <body> element
                        document.body.appendChild(buttonElement); <br>
        </script>
      </body>

      </html>
    </div>
  </h1>
<br>
<hr>


  <h1 class="top4">Day4
    <h2 class="question25">
      Ques25. Difference between undefined vs not defined vs NaN?

    </h2>

    <div class="answer25">
      Ans25.
      <br> 1. Undefined:

      Undefined is a primitive value in JavaScript that is automatically assigned to a variable that has been declared
      but
      not initialized.
      <br> It indicates the absence of a value.<br>

      <div class="out">EXAMPLE
        let x;
        console.log(x); // Output: undefined <br>
      </div>

      2. Not Defined:
      A variable that has not been declared or initialized in a program is said to be not defined.<br>
      <br> Attempting to access such a variable will result in a ReferenceError.

      <div class="out">EXAMPLE
        console.log(y); // Output: ReferenceError: y is not defined
      </div>

      3.NaN:
      NaN stands for "Not a Number". It is a special value in JavaScript that is returned when a mathematical operation
      fails to produce a meaningful result.<br>

      <div class="out">EXAMPLE
        let x = "Hello"; <br>
        let y = parseInt(x); <br>
        console.log(y); // Output: NaN <br>

      </div>
    </div>
<br>
<hr>

    <h2 class="question26">
      Ques26. Give an example of inheritance using function constructor.
    </h2>


    <div class="answer26">
      Ans26. Inheritance in JavaScript refers to the concept of creating new objects based on an existing object. The
      new
      object, also known as the child object, inherits properties and methods from the existing object, known as the
      parent object.

      One way to implement inheritance in JavaScript is by using function constructors. A function constructor is a
      function that is used to create new objects. To create a child object that inherits from a parent object using
      function constructors, we can use the Object.create() method.

    </div>


    <div class="out">

      // Parent function constructor <br>
      function Person(name, age) { <br>
      this.name = name;
      this.age = age; <br>
      }
      <br>
      // Child function constructor <br>
      function Employee(name, age, jobTitle) { <br>
      Person.call(this, name, age); <br>
      this.jobTitle = jobTitle;
      }
      <br>

      // Inherit from parent prototype <br>
      Employee.prototype = Object.create(Person.prototype); <br>
      <br>
      // Child method
      Employee.prototype.introduce = function() { <br>
      console.log("Hi, my name is " + this.name + ", and I work as a " + this.jobTitle + "."); <br>
      }; <br>
      <br>
      // Create a new Employee object <br>
      var employee1 = new Employee("Aditi", 22, "Software Engineer"); <br>
      <br>
      // Call parent and child methods
      console.log(employee1.name); // output: "Aditi" <br>
      console.log(employee1.age); // output: 22 <br>
      employee1.introduce(); // output: "Hi, my name is Aditi, and I work as a Software Engineer." <br>
      <br>
    </div>
<br>
<hr>


    <h2 class="question27">
      Ques27. what is Symbol?
    </h2>

    <div class="answer27">
      Ans27. A symbol is a unique and immutable data type that can be used as an identifier for variables.<br>

    </div>


    <div class="out">EXAMPLE
      const name1 = Symbol('Aditi'); <br>
      const name2 = Symbol('Aditi'); <br>

      console.log(name1===name2); <br>
      console.log(typeof name1); <br>
    </div>

    <br>
    <hr>



    <h2 class="question28">
      Ques28. Write code to explain map and filter in arrays?
    </h2>

    <div class="answer28">
      Ans28. 1. Map and filter are two methods in JavaScript that allow you to manipulate arrays easily.
      <br>
      <br>
      Map creates a new array by applying a function to each element in the original array.

      <div class="out">EXAMPLE OF MAP
        const numbers = [1, 2, 3, 4, 5]; <br>
        const doubledNumbers = numbers.map(num => num * 2); <br>
        console.log(doubledNumbers); <br>

      </div>

      2. Filter creates a new array containing only the elements that pass a certain test. <br>

      <div class="out">EXAMPLE OF FILTER
        const numbers = [1, 2, 3, 4, 5]; <br>
        const evenNumbers = numbers.filter(num => num % 2 === 0); <br>
        console.log(evenNumbers); <br>
      </div>
    </div>
<br>
<hr>



    <h2 class="question29">
      Ques29. Explain passed by value and passed by reference.
    </h2>


    <div class="answer29">
      Ans29. when you pass a variable to a function, it can be passed by value or by reference. <br>

      <br> When a variable is passed by value, a copy of the value is created and passed to the function.
      This means that any changes made to the parameter within the function will not affect the original variable. <br>


      <div class="out">EXAMPLE
        <br>
        function updateValue(value) { <br>
        value = 2; <br>
        }

        let num = 1; <br>
        updateValue(num); <br>
        console.log(num); <br>

      </div>

      when a variable is passed by reference, a reference to the variable is passed to the function. <br>
      <br> This means that any changes made to the parameter within the function will affect the original variable.

      <div class="out">EXAMPLE
        function updateArray(array) { <br>
        array.push(4); <br>
        }

        let arr = [1, 2, 3]; <br>
        updateArray(arr); <br>
        console.log(arr); <br>
      </div>
    </div>

<br>
<hr>


    <h2 class="question30">
      Ques30. Please explain Self Invoking Function and its code.
    </h2>


    <div class="answer30">
      <br> Ans30. A self-invoking function, also known as an immediately invoked function expression (IIFE), is a
      function that is executed as soon as it is defined. <br>
      It's a way to create a private scope for variables and functions within the function, without polluting the global
      namespace. <br>



      <div class="out">EXAMPLES
        (function() { <br>
        var message = "Hello, World!"; <br>
        console.log(message); <br>
        })();

        <br>
        <br>
        <br>
        (function() { <br>
        var counter = 0; <br>

        function increment() {
        counter++; <br>
        console.log(counter); <br>
        }

        increment(); <br>
        increment(); <br>
        })();

        increment(); // Error: increment is not defined <br>


      </div>
    </div>

<br>
<hr>


    <h2 class="question31">
      Ques31. Create a button , on click of which new Heading tag h1 should be added with text as "MERN stack" on the
      screen above button.<br>
    </h2>

    <div class="answer31">

      Ans31.
      <!DOCTYPE html>
      <html>
        <head>
          <title>Add Heading Example</title>
          <script>
            function addHeading() {
              var newHeading = document.createElement("h1");
              newHeading.textContent = "MERN stack";
      
              var button = document.getElementById("myButton");
              button.insertAdjacentElement("beforebegin", newHeading);
            }
          </script>
        </head>
        <body>
          <button id="myButton" onclick="addHeading()">Add Heading</button>
        </body>
      </html>
      

  </h1>
  </div>
</body>

</html>